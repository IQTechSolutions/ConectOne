using ShoppingModule.Domain.DataTransferObjects;
using ShoppingModule.Domain.Enums;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Security.Cryptography;
using System.Text;
using System.Web;
using ConectOne.Domain.Entities;

namespace ShoppingModule.Domain.Entities
{
    /// <summary>
    /// Represents a payment transaction, including details such as the payment method, amount, status, and associated
    /// sales orders.
    /// </summary>
    /// <remarks>This class encapsulates the details of a payment, including metadata such as the receipt
    /// number, payment date, and optional notes. It also tracks the payment's status, result, and related identifiers
    /// such as authorization codes and transaction IDs. Payments can be associated with one or more sales
    /// orders.</remarks>
    public class Payment : EntityBase<string>
    {
        #region Construction

        /// <summary>
        /// Initializes a new instance of the <see cref="Payment"/> class.
        /// </summary>
        public Payment() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="Payment"/> class using the specified payment details.
        /// </summary>
        /// <remarks>This constructor initializes the properties of the <see cref="Payment"/> class based
        /// on the values provided in the <paramref name="payment"/> parameter. Ensure that all required fields in the
        /// <paramref name="payment"/> object are properly populated before calling this constructor.</remarks>
        /// <param name="payment">An object containing the details of the payment, including receipt number, payment date, method, reference,
        /// notes, amount, and status.</param>
        public Payment(PaymenttDto payment)
        {
            ReceiptNr = payment.ReceiptNr.Value;
            PaymentDate = payment.PaymentDate;
            PaymentMethod = payment.PaymentMethod;
            PaymentReference = payment.Reference;
            Notes = payment.Notes;
            Amount = payment.Ammount;
            PaymentStatus = payment.PaymentStatus;
        }

        #endregion
        
        #region Properties

        /// <summary>
        /// Gets or sets the unique receipt number generated by the database.
        /// </summary>
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int ReceiptNr { get; set; }

        /// <summary>
        /// Gets or sets the date of the payment.
        /// </summary>
        [DataType(DataType.Date)] public DateTime PaymentDate { get; set; } = DateTime.Now;

        /// <summary>
        /// Gets or sets the payment method used for the transaction.
        /// </summary>
        public PaymentMethod PaymentMethod { get; set; } = PaymentMethod.Card;    

        /// <summary>
        /// Gets or sets the payment reference associated with the transaction.
        /// </summary>
        [MaxLength(255, ErrorMessage = "The max length for PaymentReference is 255 characters")]
        public string? PaymentReference { get; set; }

        /// <summary>
        /// Gets or sets the notes associated with the entity.
        /// </summary>
        [Column("Notes"), MaxLength(1000, ErrorMessage = "The max length for notes is 1000 characters")]
        public string? Notes { get; set; }

        /// <summary>
        /// Gets or sets the monetary amount associated with the transaction.
        /// </summary>
        public double Amount { get; set; }

        #region Paygate

        /// <summary>
        /// Gets or sets the current payment status of the transaction.
        /// </summary>
        public PaymentStatus PaymentStatus { get; set; } = PaymentStatus.Unknown;

        /// <summary>
        /// Gets or sets the result of the payment operation.
        /// </summary>
        public PaymentResult PaymentResult { get; set; } = PaymentResult.None;

        /// <summary>
        /// Gets or sets a description of the payment result, providing additional details about the outcome of the
        /// payment process.
        /// </summary>
        public string? PaymentResultDescription { get; set; }

        /// <summary>
        /// Gets or sets the authorization code used for authentication or verification purposes.
        /// </summary>
        public string? AuthCode { get; set; }

        /// <summary>
        /// Gets or sets the unique identifier for the transaction.
        /// </summary>
        public string? TransactionId { get; set; }

        #endregion

        #endregion

        #region Collections 

        /// <summary>
        /// Gets or sets the collection of sales orders associated with the payments.
        /// </summary>
        public ICollection<SalesOrderPayment> SalesOrders { get; set; } = new List<SalesOrderPayment>();

        #endregion

        /// <summary>
        /// Computes the MD5 hash of the concatenated values from the specified dictionary and an encryption key.
        /// </summary>
        /// <remarks>The method concatenates all the values in the <paramref name="data"/> dictionary in
        /// the order they are enumerated, appends the <paramref name="encryptionKey"/>, and computes the MD5 hash of
        /// the resulting string. The hash is returned as a lowercase hexadecimal string.</remarks>
        /// <param name="data">A dictionary containing key-value pairs whose values will be concatenated to form the input for the hash
        /// computation.</param>
        /// <param name="encryptionKey">A string that is appended to the concatenated values from the dictionary before computing the hash.</param>
        /// <returns>A hexadecimal string representation of the computed MD5 hash.</returns>
        public string GetMd5Hash(Dictionary<string, string> data, string encryptionKey)
        {
            using (MD5 md5Hash = MD5.Create())
            {
                StringBuilder input = new StringBuilder();
                foreach (string value in data.Values)
                {
                    input.Append(value);
                }

                input.Append(encryptionKey);

                byte[] hash = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(input.ToString()));

                StringBuilder sBuilder = new StringBuilder();

                for (int i = 0; i < hash.Length; i++)
                {
                    sBuilder.Append(hash[i].ToString("x2"));
                }
                return sBuilder.ToString();
            }
        }

        /// <summary>
        /// Verifies whether the provided MD5 hash matches the hash generated from the specified data and encryption
        /// key.
        /// </summary>
        /// <remarks>This method performs a case-insensitive comparison of the computed hash and the
        /// provided hash. Ensure that the <paramref name="data"/> dictionary contains all necessary key-value pairs
        /// except the "CHECKSUM" key,  which is ignored during hash computation.</remarks>
        /// <param name="data">A dictionary containing key-value pairs of data to be hashed. The key "CHECKSUM" is excluded from the hash
        /// computation.</param>
        /// <param name="encryptionKey">The encryption key used to generate the hash.</param>
        /// <param name="hash">The MD5 hash to verify against the computed hash.</param>
        /// <returns><see langword="true"/> if the computed hash matches the provided hash; otherwise, <see langword="false"/>.</returns>
        public bool VerifyMd5Hash(Dictionary<string, string> data, string encryptionKey, string hash)
        {
            Dictionary<string, string> hashDict = new Dictionary<string, string>();

            foreach (string key in data.Keys)
            {
                if (key != "CHECKSUM")
                {
                    hashDict.Add(key, data[key]);
                }
            }

            string hashOfInput = GetMd5Hash(hashDict, encryptionKey);

            StringComparer comparer = StringComparer.OrdinalIgnoreCase;

            if (0 == comparer.Compare(hashOfInput, hash))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Converts the specified dictionary of key-value pairs into a URL-encoded query string.
        /// </summary>
        /// <remarks>Each key-value pair in the dictionary is encoded using <see
        /// cref="HttpUtility.UrlEncode(string)"/> and concatenated in the format "key=value", separated by '&'. The
        /// resulting string does not include a leading '&'.</remarks>
        /// <param name="request">A dictionary containing the key-value pairs to be encoded. Keys and values cannot be null.</param>
        /// <returns>A URL-encoded query string representing the key-value pairs in the dictionary. If the dictionary is empty,
        /// an empty string is returned.</returns>
        public string ToUrlEncodedString(Dictionary<string, string> request)
        {
            StringBuilder builder = new StringBuilder();

            foreach (string key in request.Keys)
            {
                builder.Append("&");
                builder.Append(key);
                builder.Append("=");
                builder.Append(HttpUtility.UrlEncode(request[key]));
            }

            string result = builder.ToString().TrimStart('&');

            return result;
        }

        /// <summary>
        /// Converts a URL-encoded query string into a dictionary of key-value pairs.
        /// </summary>
        /// <remarks>This method assumes that the input string is properly formatted as a URL-encoded
        /// query string. If the input contains invalid formatting, an exception may be thrown during parsing.</remarks>
        /// <param name="response">The URL-encoded query string to parse. Each key-value pair should be separated by an ampersand ('&'), and
        /// keys and values should be separated by an equals sign ('=').</param>
        /// <returns>A <see cref="Dictionary{TKey, TValue}"/> containing the parsed key-value pairs. The keys are the parameter
        /// names, and the values are the decoded parameter values.</returns>
        public Dictionary<string, string> ToDictionary(string response)
        {
            Dictionary<string, string> result = new Dictionary<string, string>();

            string[] valuePairs = response.Split('&');
            foreach (string valuePair in valuePairs)
            {
                string[] values = valuePair.Split('=');
                result.Add(values[0], HttpUtility.UrlDecode(values[1]));
            }

            return result;
        }
    }
}
